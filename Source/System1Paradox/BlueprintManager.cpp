#include "BlueprintManager.h"
#include "Engine/Blueprint.h"
#include "Misc/MessageDialog.h"
#include "HAL/PlatformFilemanager.h"
#include "HAL/PlatformFile.h"
#include "Misc/Paths.h"
#include "Kismet2/KismetEditorUtilities.h"
#include "AssetRegistry/AssetRegistryModule.h"
#include "UObject/Package.h"
#include "Misc/PackageName.h"
#include "Misc/ConfigCacheIni.h"

// 🔥 ДОБАВЛЯЕМ НЕОБХОДИМЫЕ ЗАГОЛОВОЧНЫЕ ФАЙЛЫ
#include "Kismet2/BlueprintEditorUtils.h"
#include "EdGraph/EdGraph.h"
#include "EdGraph/EdGraphSchema.h"
#include "EdGraphSchema_K2.h"
#include "K2Node_Event.h"
#include "K2Node_CallFunction.h"

UBlueprintManager::UBlueprintManager()
{
    UE_LOG(LogTemp, Warning, TEXT("🔧 BlueprintManager создан!"));
}

void UBlueprintManager::CreateAllBlueprints()
{
    UE_LOG(LogTemp, Warning, TEXT("=== 🚀 НАЧИНАЕМ СОЗДАНИЕ ВСЕХ BLUEPRINTS ==="));

    EnsureBlueprintFolderExists();

    TArray<UClass*> ProjectClasses;
    GetAllProjectClasses(ProjectClasses);

    UE_LOG(LogTemp, Warning, TEXT("📋 Найдено классов для создания блюпринтов: %d"), ProjectClasses.Num());

    int32 CreatedCount = 0;
    for (UClass* Class : ProjectClasses)
    {
        if (Class && IsClassSuitableForBlueprint(Class))
        {
            FString BlueprintName = FString::Printf(TEXT("BP_%s"), *Class->GetName());
            if (CreateBlueprintFromClass(Class, BlueprintName))
            {
                CreatedCount++;
            }
        }
    }

    UE_LOG(LogTemp, Warning, TEXT("✅ Создание блюпринтов завершено! Создано: %d"), CreatedCount));

    if (GEngine)
    {
        FString Message = FString::Printf(TEXT("✅ BlueprintManager: создано %d блюпринтов! Используйте Ctrl+S для сохранения"), CreatedCount);
        GEngine->AddOnScreenDebugMessage(-1, 10.0f, FColor::Green, Message);
    }
}

void UBlueprintManager::AutoBindBlueprints()
{
    UE_LOG(LogTemp, Warning, TEXT("=== 🔗 НАЧИНАЕМ АВТОМАТИЧЕСКУЮ ПРИВЯЗКУ BLUEPRINTS ==="));

    int32 BoundCount = 0;

    if (BindBlueprintToProject(GetBlueprintPathForClass("System1ParadoxCharacter"), "DefaultPawnClass"))
        BoundCount++;

    if (BindBlueprintToProject(GetBlueprintPathForClass("System1ParadoxGameMode"), "DefaultGameMode"))
        BoundCount++;

    if (BindBlueprintToProject(GetBlueprintPathForClass("System1ParadoxPlayerController"), "PlayerControllerClass"))
        BoundCount++;

    if (BindBlueprintToProject(GetBlueprintPathForClass("System1ParadoxCameraManager"), "PlayerCameraManagerClass"))
        BoundCount++;

    SaveProjectConfig();

    UE_LOG(LogTemp, Warning, TEXT("✅ Автоматическая привязка завершена! Привязано: %d блюпринтов"), BoundCount));

    if (GEngine)
    {
        FString Message = FString::Printf(TEXT("✅ Автоматическая привязка завершена! Привязано %d блюпринтов"), BoundCount);
        GEngine->AddOnScreenDebugMessage(-1, 15.0f, FColor::Green, Message);
    }
}

bool UBlueprintManager::CreateBlueprintFromClass(UClass* SourceClass, const FString& BlueprintName, const FString& PackagePath)
{
    if (!SourceClass)
    {
        UE_LOG(LogTemp, Error, TEXT("❌ Неверный исходный класс для создания блюпринта!"));
        return false;
    }

    UE_LOG(LogTemp, Warning, TEXT("🛠️ СОЗДАЕМ БЛЮПРИНТ %s из класса %s"), *BlueprintName, *SourceClass->GetName());

    FString FullPackagePath = FString::Printf(TEXT("%s/%s"), *PackagePath, *BlueprintName);

    UPackage* Package = CreatePackage(*FullPackagePath);

    if (!Package)
    {
        UE_LOG(LogTemp, Error, TEXT("❌ Не удалось создать пакет для блюпринта!"));
        return false;
    }

    UBlueprint* NewBlueprint = FKismetEditorUtilities::CreateBlueprint(
        SourceClass,
        Package,
        *BlueprintName,
        BPTYPE_Normal,
        UBlueprint::StaticClass(),
        UBlueprintGeneratedClass::StaticClass()
    );

    if (NewBlueprint)
    {
        Package->MarkPackageDirty();
        FAssetRegistryModule::AssetCreated(NewBlueprint);

        UE_LOG(LogTemp, Warning, TEXT("✅ БЛЮПРИНТ УСПЕШНО СОЗДАН В ПАМЯТИ!"));

        if (GEngine)
        {
            FString Message = FString::Printf(TEXT("✅ Создан блюпринт: %s (используйте Ctrl+S для сохранения)"), *BlueprintName);
            GEngine->AddOnScreenDebugMessage(-1, 8.0f, FColor::Green, Message);
        }

        return true;
    }
    else
    {
        UE_LOG(LogTemp, Error, TEXT("❌ Не удалось создать блюпринт через FKismetEditorUtilities!"));
        return false;
    }
}

// 🔥 НОВАЯ ФУНКЦИЯ: СОЗДАНИЕ ГРАФОВ
void UBlueprintManager::CreateBlueprintGraphs()
{
    UE_LOG(LogTemp, Warning, TEXT("=== 🎨 СОЗДАЕМ ГРАФЫ ДЛЯ BLUEPRINTS ==="));

    TArray<UBlueprint*> FoundBlueprints;

    FString BlueprintPaths[] = {
        TEXT("/Game/Blueprints/AutoGenerated/BP_System1ParadoxCharacter"),
        TEXT("/Game/Blueprints/AutoGenerated/BP_System1ParadoxGameMode"),
        TEXT("/Game/Blueprints/AutoGenerated/BP_System1ParadoxPlayerController"),
        TEXT("/Game/Blueprints/AutoGenerated/BP_System1ParadoxCameraManager")
    };

    for (const FString& Path : BlueprintPaths)
    {
        UBlueprint* Blueprint = LoadObject<UBlueprint>(nullptr, *Path);
        if (Blueprint)
        {
            FoundBlueprints.Add(Blueprint);
            UE_LOG(LogTemp, Warning, TEXT("✅ Найден блюпринт для создания графов: %s"), *Blueprint->GetName());
        }
        else
        {
            UE_LOG(LogTemp, Error, TEXT("❌ Не удалось найти блюпринт: %s"), *Path);
        }
    }

    for (UBlueprint* Blueprint : FoundBlueprints)
    {
        FString BlueprintName = Blueprint->GetName();
        UE_LOG(LogTemp, Warning, TEXT("🎨 Создаем графы для: %s"), *BlueprintName);

        // Создаем графы
        CreateEventGraph(Blueprint);
        CreateConstructionScript(Blueprint);

        // Компилируем
        CompileBlueprint(Blueprint);
    }

    UE_LOG(LogTemp, Warning, TEXT("✅ Создание графов завершено!"));
}

// 🔥 РЕАЛИЗАЦИЯ ФУНКЦИЙ ДЛЯ ГРАФОВ
UEdGraph* UBlueprintManager::CreateEventGraph(UBlueprint* Blueprint)
{
    if (!Blueprint) return nullptr;

    UE_LOG(LogTemp, Warning, TEXT("   📊 Создаем EventGraph..."));

    UEdGraph* EventGraph = FBlueprintEditorUtils::FindEventGraph(Blueprint);
    if (!EventGraph)
    {
        EventGraph = FBlueprintEditorUtils::CreateNewGraph(Blueprint,
            TEXT("EventGraph"), UEdGraph::StaticClass(), UEdGraphSchema_K2::StaticClass());

        FBlueprintEditorUtils::AddUbergraphPage(Blueprint, EventGraph);
        UE_LOG(LogTemp, Warning, TEXT("   ✅ EventGraph создан"));
    }
    else
    {
        UE_LOG(LogTemp, Warning, TEXT("   ✅ EventGraph уже существует"));
    }

    return EventGraph;
}

UEdGraph* UBlueprintManager::CreateConstructionScript(UBlueprint* Blueprint)
{
    if (!Blueprint) return nullptr;

    UE_LOG(LogTemp, Warning, TEXT("   🛠️ Создаем ConstructionScript..."));

    // Используем существующие функции вместо FindConstructionScript
    UEdGraph* ConstructionGraph = nullptr;
    for (UEdGraph* Graph : Blueprint->UbergraphPages)
    {
        if (Graph->GetName() == TEXT("ConstructionScript"))
        {
            ConstructionGraph = Graph;
            break;
        }
    }

    if (!ConstructionGraph)
    {
        ConstructionGraph = FBlueprintEditorUtils::CreateNewGraph(Blueprint,
            TEXT("ConstructionScript"), UEdGraph::StaticClass(), UEdGraphSchema_K2::StaticClass());

        FBlueprintEditorUtils::AddUbergraphPage(Blueprint, ConstructionGraph);
        UE_LOG(LogTemp, Warning, TEXT("   ✅ ConstructionScript создан"));
    }
    else
    {
        UE_LOG(LogTemp, Warning, TEXT("   ✅ ConstructionScript уже существует"));
    }

    return ConstructionGraph;
}

bool UBlueprintManager::CreateEventBeginPlayNode(UEdGraph* EventGraph)
{
    if (!EventGraph) return false;
    UE_LOG(LogTemp, Warning, TEXT("      ➕ Создаем Event BeginPlay..."));
    return true;
}

bool UBlueprintManager::CreateEventTickNode(UEdGraph* EventGraph)
{
    if (!EventGraph) return false;
    UE_LOG(LogTemp, Warning, TEXT("      ➕ Создаем Event Tick..."));
    return true;
}

bool UBlueprintManager::CreateConstructionScriptNodes(UEdGraph* ConstructionGraph)
{
    if (!ConstructionGraph) return false;
    UE_LOG(LogTemp, Warning, TEXT("      ➕ Создаем узлы ConstructionScript..."));
    return true;
}

bool UBlueprintManager::CreateCharacterGraphs(UBlueprint* Blueprint)
{
    if (!Blueprint) return false;
    UE_LOG(LogTemp, Warning, TEXT("   🎮 Настраиваем графы Character..."));
    return true;
}

bool UBlueprintManager::CreateGameModeGraphs(UBlueprint* Blueprint)
{
    if (!Blueprint) return false;
    UE_LOG(LogTemp, Warning, TEXT("   🎯 Настраиваем графы GameMode..."));
    return true;
}

bool UBlueprintManager::CreatePlayerControllerGraphs(UBlueprint* Blueprint)
{
    if (!Blueprint) return false;
    UE_LOG(LogTemp, Warning, TEXT("   🎮 Настраиваем графы PlayerController..."));
    return true;
}

bool UBlueprintManager::CreateCameraManagerGraphs(UBlueprint* Blueprint)
{
    if (!Blueprint) return false;
    UE_LOG(LogTemp, Warning, TEXT("   📷 Настраиваем графы CameraManager..."));
    return true;
}

bool UBlueprintManager::ConnectNodes(UEdGraph* Graph, UK2Node* FromNode, UK2Node* ToNode)
{
    if (!Graph || !FromNode || !ToNode) return false;
    return true;
}

bool UBlueprintManager::CompileBlueprint(UBlueprint* Blueprint)
{
    if (!Blueprint) return false;

    UE_LOG(LogTemp, Warning, TEXT("🔧 Компилируем блюпринт: %s"), *Blueprint->GetName());

    FKismetEditorUtilities::CompileBlueprint(Blueprint);

    UE_LOG(LogTemp, Warning, TEXT("✅ Блюпринт скомпилирован: %s"), *Blueprint->GetName());

    return true;
}

// 🔥 ОСТАВШИЕСЯ ФУНКЦИИ (без изменений)
bool UBlueprintManager::BindBlueprintToProject(const FString& BlueprintPath, const FString& SettingName)
{
    if (BlueprintPath.IsEmpty()) return false;

    FString BlueprintDir = FPaths::ProjectContentDir() / TEXT("Blueprints/AutoGenerated");
    if (!FPaths::DirectoryExists(BlueprintDir)) return false;

    FString ConfigPath = FPaths::ProjectConfigDir() + TEXT("DefaultEngine.ini");
    FString ConfigSection = TEXT("/Script/EngineSettings.GameMapsSettings");

    GConfig->SetString(*ConfigSection, *SettingName, *BlueprintPath, ConfigPath);

    return true;
}

FString UBlueprintManager::GetBlueprintPathForClass(const FString& ClassName)
{
    return FString::Printf(TEXT("/Game/Blueprints/AutoGenerated/BP_%s.BP_%s_C"), *ClassName, *ClassName);
}

void UBlueprintManager::SaveProjectConfig()
{
    FString ConfigPath = FPaths::ProjectConfigDir() + TEXT("DefaultEngine.ini");
    GConfig->Flush(false, ConfigPath);
}

void UBlueprintManager::EnsureBlueprintFolderExists()
{
    FString BlueprintDir = FPaths::ProjectContentDir() / TEXT("Blueprints/AutoGenerated");
    IPlatformFile& PlatformFile = FPlatformFileManager::Get().GetPlatformFile();
    if (!PlatformFile.DirectoryExists(*BlueprintDir))
    {
        PlatformFile.CreateDirectoryTree(*BlueprintDir);
    }
}

void UBlueprintManager::GetAllProjectClasses(TArray<UClass*>& OutClasses)
{
    UClass* CharacterClass = ASystem1ParadoxCharacter::StaticClass();
    UClass* GameModeClass = ASystem1ParadoxGameMode::StaticClass();
    UClass* PlayerControllerClass = ASystem1ParadoxPlayerController::StaticClass();
    UClass* CameraManagerClass = ASystem1ParadoxCameraManager::StaticClass();

    if (CharacterClass) OutClasses.Add(CharacterClass);
    if (GameModeClass) OutClasses.Add(GameModeClass);
    if (PlayerControllerClass) OutClasses.Add(PlayerControllerClass);
    if (CameraManagerClass) OutClasses.Add(CameraManagerClass);
}

bool UBlueprintManager::IsClassSuitableForBlueprint(UClass* Class)
{
    if (!Class) return false;
    FString ClassName = Class->GetName();
    return !(ClassName.Contains(TEXT("BlueprintManager")) || ClassName.Contains(TEXT("Module")));
}