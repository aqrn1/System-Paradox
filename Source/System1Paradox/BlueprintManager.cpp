#include "BlueprintManager.h"
#include "Engine/Blueprint.h"
#include "Kismet2/KismetEditorUtilities.h"
#include "Misc/MessageDialog.h"
#include "HAL/PlatformFilemanager.h"
#include "HAL/PlatformFile.h"
#include "Misc/Paths.h"

UBlueprintManager::UBlueprintManager()
{
    UE_LOG(LogTemp, Warning, TEXT("🔧 BlueprintManager создан!"));
}

void UBlueprintManager::CreateAllBlueprints()
{
    UE_LOG(LogTemp, Warning, TEXT("=== 🚀 НАЧИНАЕМ СОЗДАНИЕ ВСЕХ BLUEPRINTS ==="));

    // Создаем папку для блюпринтов
    EnsureBlueprintFolderExists();

    // Получаем все классы проекта для создания блюпринтов
    TArray<UClass*> ProjectClasses;
    GetAllProjectClasses(ProjectClasses);

    UE_LOG(LogTemp, Warning, TEXT("📋 Найдено классов для создания блюпринтов: %d"), ProjectClasses.Num());

    // Создаем блюпринты для каждого класса
    int32 CreatedCount = 0;
    for (UClass* Class : ProjectClasses)
    {
        if (Class && IsClassSuitableForBlueprint(Class))
        {
            FString BlueprintName = FString::Printf(TEXT("BP_%s"), *Class->GetName());
            if (CreateBlueprintFromClass(Class, BlueprintName))
            {
                CreatedCount++;
            }
        }
    }

    UE_LOG(LogTemp, Warning, TEXT("✅ Создание блюпринтов завершено! Создано: %d"), CreatedCount);
}

bool UBlueprintManager::CreateBlueprintFromClass(UClass* SourceClass, const FString& BlueprintName, const FString& PackagePath)
{
    if (!SourceClass)
    {
        UE_LOG(LogTemp, Error, TEXT("❌ Неверный исходный класс для создания блюпринта!"));
        return false;
    }

    UE_LOG(LogTemp, Warning, TEXT("🛠️ Создаем блюпринт %s из класса %s"),
        *BlueprintName, *SourceClass->GetName());

    FString FullPackagePath = FString::Printf(TEXT("%s/%s"), *PackagePath, *BlueprintName);

    UE_LOG(LogTemp, Warning, TEXT("   📁 Полный путь: %s"), *FullPackagePath);
    UE_LOG(LogTemp, Warning, TEXT("   🎯 Родительский класс: %s"), *SourceClass->GetName());
    UE_LOG(LogTemp, Warning, TEXT("   📝 Имя класса: %s"), *SourceClass->GetFullName());

    // Проверяем, является ли класс валидным для создания блюпринта
    if (!SourceClass->HasAnyClassFlags(CLASS_EditInlineNew) && !SourceClass->IsChildOf<AActor>())
    {
        UE_LOG(LogTemp, Warning, TEXT("   ⚠️ Класс не наследуется от AActor - могут быть ограничения"));
    }

    // Пока просто логируем - в следующей версии добавим реальное создание
    UE_LOG(LogTemp, Warning, TEXT("   ✅ Логирование завершено (реальное создание в следующей версии)"));

    return true;
}

void UBlueprintManager::EnsureBlueprintFolderExists()
{
    FString BlueprintDir = FPaths::ProjectContentDir() / TEXT("Blueprints/AutoGenerated");

    IPlatformFile& PlatformFile = FPlatformFileManager::Get().GetPlatformFile();
    if (!PlatformFile.DirectoryExists(*BlueprintDir))
    {
        PlatformFile.CreateDirectoryTree(*BlueprintDir);
        UE_LOG(LogTemp, Warning, TEXT("📁 Создана папка для блюпринтов: %s"), *BlueprintDir);
    }
    else
    {
        UE_LOG(LogTemp, Warning, TEXT("📁 Папка для блюпринтов уже существует: %s"), *BlueprintDir);
    }
}

void UBlueprintManager::GetAllProjectClasses(TArray<UClass*>& OutClasses)
{
    UE_LOG(LogTemp, Warning, TEXT("🔍 Ищем C++ классы проекта..."));

    // Способ 1: Прямое добавление классов через StaticClass()
    UE_LOG(LogTemp, Warning, TEXT("📋 Добавляем классы вручную..."));

    // Добавляем основные классы проекта
    UClass* CharacterClass = ASystem1ParadoxCharacter::StaticClass();
    UClass* GameModeClass = ASystem1ParadoxGameMode::StaticClass();
    UClass* PlayerControllerClass = ASystem1ParadoxPlayerController::StaticClass();
    UClass* CameraManagerClass = ASystem1ParadoxCameraManager::StaticClass();

    if (CharacterClass)
    {
        OutClasses.Add(CharacterClass);
        UE_LOG(LogTemp, Warning, TEXT("   ✅ Добавлен: %s"), *CharacterClass->GetName());
    }
    else
    {
        UE_LOG(LogTemp, Error, TEXT("   ❌ System1ParadoxCharacter не найден!"));
    }

    if (GameModeClass)
    {
        OutClasses.Add(GameModeClass);
        UE_LOG(LogTemp, Warning, TEXT("   ✅ Добавлен: %s"), *GameModeClass->GetName());
    }
    else
    {
        UE_LOG(LogTemp, Error, TEXT("   ❌ System1ParadoxGameMode не найден!"));
    }

    if (PlayerControllerClass)
    {
        OutClasses.Add(PlayerControllerClass);
        UE_LOG(LogTemp, Warning, TEXT("   ✅ Добавлен: %s"), *PlayerControllerClass->GetName());
    }
    else
    {
        UE_LOG(LogTemp, Error, TEXT("   ❌ System1ParadoxPlayerController не найден!"));
    }

    if (CameraManagerClass)
    {
        OutClasses.Add(CameraManagerClass);
        UE_LOG(LogTemp, Warning, TEXT("   ✅ Добавлен: %s"), *CameraManagerClass->GetName());
    }
    else
    {
        UE_LOG(LogTemp, Error, TEXT("   ❌ System1ParadoxCameraManager не найден!"));
    }

    UE_LOG(LogTemp, Warning, TEXT("📋 Итоговое количество классов: %d"), OutClasses.Num());
}

bool UBlueprintManager::IsClassSuitableForBlueprint(UClass* Class)
{
    if (!Class) return false;

    // Исключаем некоторые классы
    FString ClassName = Class->GetName();
    if (ClassName.Contains(TEXT("BlueprintManager")) ||
        ClassName.Contains(TEXT("Module")))
    {
        return false;
    }

    return true;
}