#include "BlueprintManager.h"
#include "Engine/Blueprint.h"
#include "Misc/MessageDialog.h"
#include "HAL/PlatformFilemanager.h"
#include "HAL/PlatformFile.h"
#include "Misc/Paths.h"
#include "Kismet2/KismetEditorUtilities.h"
#include "AssetRegistry/AssetRegistryModule.h"
#include "UObject/Package.h"
#include "Misc/PackageName.h"
#include "Misc/ConfigCacheIni.h"
#include "Kismet2/BlueprintEditorUtils.h"

UBlueprintManager::UBlueprintManager()
{
    UE_LOG(LogTemp, Warning, TEXT("🔧 BlueprintManager создан!"));
}

void UBlueprintManager::CreateAllBlueprints()
{
    UE_LOG(LogTemp, Warning, TEXT("=== 🚀 НАЧИНАЕМ СОЗДАНИЕ ВСЕХ BLUEPRINTS ==="));
    EnsureBlueprintFolderExists();

    TArray<UClass*> ProjectClasses;
    GetAllProjectClasses(ProjectClasses);

    UE_LOG(LogTemp, Warning, TEXT("📋 Найдено классов для создания блюпринтов: %d"), ProjectClasses.Num());

    int32 CreatedCount = 0;
    for (UClass* Class : ProjectClasses)
    {
        if (Class && IsClassSuitableForBlueprint(Class))
        {
            FString BlueprintName = FString::Printf(TEXT("BP_%s"), *Class->GetName());
            if (CreateBlueprintFromClass(Class, BlueprintName))
            {
                CreatedCount++;
            }
        }
    }

    UE_LOG(LogTemp, Warning, TEXT("✅ Создание блюпринтов завершено! Создано: %d"), CreatedCount);
}

void UBlueprintManager::AutoBindBlueprints()
{
    UE_LOG(LogTemp, Warning, TEXT("=== 🔗 НАЧИНАЕМ АВТОМАТИЧЕСКУЮ ПРИВЯЗКУ BLUEPRINTS ==="));

    int32 BoundCount = 0;
    if (BindBlueprintToProject(GetBlueprintPathForClass("System1ParadoxCharacter"), "DefaultPawnClass")) BoundCount++;
    if (BindBlueprintToProject(GetBlueprintPathForClass("System1ParadoxGameMode"), "DefaultGameMode")) BoundCount++;
    if (BindBlueprintToProject(GetBlueprintPathForClass("System1ParadoxPlayerController"), "PlayerControllerClass")) BoundCount++;
    if (BindBlueprintToProject(GetBlueprintPathForClass("System1ParadoxCameraManager"), "PlayerCameraManagerClass")) BoundCount++;

    SaveProjectConfig();
    UE_LOG(LogTemp, Warning, TEXT("✅ Автоматическая привязка завершена! Привязано: %d блюпринтов"), BoundCount);
}

bool UBlueprintManager::CreateBlueprintFromClass(UClass* SourceClass, const FString& BlueprintName, const FString& PackagePath)
{
    if (!SourceClass) return false;

    FString FullPackagePath = FString::Printf(TEXT("%s/%s"), *PackagePath, *BlueprintName);

    UPackage* ExistingPackage = FindPackage(nullptr, *FullPackagePath);
    if (ExistingPackage != nullptr)
    {
        UBlueprint* ExistingBlueprint = FindObject<UBlueprint>(ExistingPackage, *BlueprintName);
        if (ExistingBlueprint)
        {
            UE_LOG(LogTemp, Warning, TEXT("ℹ️ Блюпринт %s уже существует. Пропускаем создание."), *BlueprintName);
            return true;
        }
    }

    // СТАЛО (исправлено):
    UE_LOG(LogTemp, Warning, TEXT("🛠️ СОЗДАЕМ БЛЮПРИНТ %s из класса %s"), *BlueprintName, *SourceClass->GetName());

    UPackage* Package = CreatePackage(*FullPackagePath);
    if (!Package) return false;

    UBlueprint* NewBlueprint = FKismetEditorUtilities::CreateBlueprint(
        SourceClass,
        Package,
        *BlueprintName,
        BPTYPE_Normal,
        UBlueprint::StaticClass(),
        UBlueprintGeneratedClass::StaticClass()
    );

    if (NewBlueprint)
    {
        Package->MarkPackageDirty();
        FAssetRegistryModule::AssetCreated(NewBlueprint);
        UE_LOG(LogTemp, Warning, TEXT("✅ БЛЮПРИНТ УСПЕШНО СОЗДАН!"));
        return true;
    }
    return false;
}

void UBlueprintManager::CreateBlueprintGraphs()
{
    UE_LOG(LogTemp, Warning, TEXT("=== 🎨 СОЗДАЕМ ГРАФЫ ДЛЯ BLUEPRINTS ==="));

    TArray<UBlueprint*> FoundBlueprints;
    FString BlueprintPaths[] = {
        TEXT("/Game/Blueprints/AutoGenerated/BP_System1ParadoxCharacter"),
        TEXT("/Game/Blueprints/AutoGenerated/BP_System1ParadoxGameMode"),
        TEXT("/Game/Blueprints/AutoGenerated/BP_System1ParadoxPlayerController"),
        TEXT("/Game/Blueprints/AutoGenerated/BP_System1ParadoxCameraManager")
    };

    for (const FString& Path : BlueprintPaths)
    {
        UBlueprint* Blueprint = LoadObject<UBlueprint>(nullptr, *Path);
        if (Blueprint) FoundBlueprints.Add(Blueprint);
    }

    for (UBlueprint* Blueprint : FoundBlueprints)
    {
        FString BlueprintName = Blueprint->GetName();
        UE_LOG(LogTemp, Warning, TEXT("🎨 Компилируем блюпринт: %s"), *BlueprintName);
        CompileBlueprint(Blueprint);
        FBlueprintEditorUtils::RefreshAllNodes(Blueprint);
        Blueprint->MarkPackageDirty();
    }

    UE_LOG(LogTemp, Warning, TEXT("✅ Создание графов завершено! Блюпринты скомпилированы."));
}

void UBlueprintManager::SetupCreatedBlueprints()
{
    UE_LOG(LogTemp, Warning, TEXT("=== ⚙️ ПРИВЯЗЫВАЕМ СОЗДАННЫЕ BLUEPRINTS ==="));
    AutoBindBlueprints();
}

bool UBlueprintManager::CompileBlueprint(UBlueprint* Blueprint)
{
    if (!Blueprint) return false;
    UE_LOG(LogTemp, Warning, TEXT("🔧 Компилируем блюпринт: %s"), *Blueprint->GetName());
    FKismetEditorUtilities::CompileBlueprint(Blueprint);
    UE_LOG(LogTemp, Warning, TEXT("✅ Блюпринт скомпилирован: %s"), *Blueprint->GetName());
    return true;
}

bool UBlueprintManager::BindBlueprintToProject(const FString& BlueprintPath, const FString& SettingName)
{
    if (BlueprintPath.IsEmpty()) return false;
    FString BlueprintDir = FPaths::ProjectContentDir() / TEXT("Blueprints/AutoGenerated");
    if (!FPaths::DirectoryExists(BlueprintDir)) return false;

    FString ConfigPath = FPaths::ProjectConfigDir() + TEXT("DefaultEngine.ini");
    FString ConfigSection = TEXT("/Script/EngineSettings.GameMapsSettings");

    GConfig->SetString(*ConfigSection, *SettingName, *BlueprintPath, ConfigPath);
    return true;
}

FString UBlueprintManager::GetBlueprintPathForClass(const FString& ClassName)
{
    return FString::Printf(TEXT("/Game/Blueprints/AutoGenerated/BP_%s.BP_%s_C"), *ClassName, *ClassName);
}

void UBlueprintManager::SaveProjectConfig()
{
    FString ConfigPath = FPaths::ProjectConfigDir() + TEXT("DefaultEngine.ini");
    GConfig->Flush(false, ConfigPath);
}

void UBlueprintManager::EnsureBlueprintFolderExists()
{
    FString BlueprintDir = FPaths::ProjectContentDir() / TEXT("Blueprints/AutoGenerated");
    IPlatformFile& PlatformFile = FPlatformFileManager::Get().GetPlatformFile();
    if (!PlatformFile.DirectoryExists(*BlueprintDir))
    {
        PlatformFile.CreateDirectoryTree(*BlueprintDir);
    }
}

void UBlueprintManager::GetAllProjectClasses(TArray<UClass*>& OutClasses)
{
    UClass* CharacterClass = ASystem1ParadoxCharacter::StaticClass();
    UClass* GameModeClass = ASystem1ParadoxGameMode::StaticClass();
    UClass* PlayerControllerClass = ASystem1ParadoxPlayerController::StaticClass();
    UClass* CameraManagerClass = ASystem1ParadoxCameraManager::StaticClass();

    if (CharacterClass) OutClasses.Add(CharacterClass);
    if (GameModeClass) OutClasses.Add(GameModeClass);
    if (PlayerControllerClass) OutClasses.Add(PlayerControllerClass);
    if (CameraManagerClass) OutClasses.Add(CameraManagerClass);
}

bool UBlueprintManager::IsClassSuitableForBlueprint(UClass* Class)
{
    if (!Class) return false;
    FString ClassName = Class->GetName();
    return !(ClassName.Contains(TEXT("BlueprintManager")) || ClassName.Contains(TEXT("Module")));
}